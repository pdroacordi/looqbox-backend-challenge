package io.acordi.looqboxbackendchallenge.core.util.sorting.algorithms.implementation;

import io.acordi.looqboxbackendchallenge.core.util.sorting.algorithms.SortingAlgorithm;

import java.util.Comparator;
import java.util.List;

public class BubbleSort<T> implements SortingAlgorithm<T> {

    // I am not actually using bubble sort, merge sort is just superior.
    // I just wanted to show that it would be pretty easy to swap between sorting algorithms if asked.
    // The comment below was generated by GPT just to standardize, don't bother reading it.
    //
    // Bubble Sort is a simple and straightforward sorting algorithm that repeatedly steps through the list,
    // compares adjacent elements, and swaps them if they are in the wrong order.
    // It "bubbles" the largest unsorted element to the end of the array after each pass.
    //
    // Time Complexity:
    // - Best case: O(n) (when the array is already sorted, with an optimization check).
    // - Average case: O(n²).
    // - Worst case: O(n²).
    // This makes Bubble Sort inefficient for large datasets compared to algorithms like Merge Sort or Quick Sort.
    //
    // Space Complexity:
    // - O(1): Bubble Sort is an in-place algorithm, meaning it does not require additional space
    //         proportional to the input size.
    //
    // How it works:
    // 1. Traverse the array from the beginning to the end.
    // 2. Compare each pair of adjacent elements and swap them if they are out of order.
    // 3. Repeat the process for each element, reducing the range after every pass,
    //    as the largest element is "bubbled" to its correct position.
    //
    // Advantages:
    // - Simple to implement and easy to understand.
    // - Stable: It preserves the relative order of equal elements.
    // - Works well for small datasets or nearly sorted arrays (with optimization).
    //
    // Disadvantages:
    // - Very inefficient for large datasets due to its quadratic time complexity.
    // - Performs unnecessary comparisons even when the array is sorted unless optimized.
    //
    // Usage:
    // Bubble Sort is primarily used for educational purposes or in cases where simplicity and stability
    // are more important than performance. It can also be useful for small datasets or nearly sorted data.
    //
    // Implementation Details:
    // - This implementation uses generics (<T>) and a Comparator<T> to allow sorting of any object type.
    // - This makes the algorithm versatile and capable of handling strings, numbers, or custom objects
    //   with a user-defined sorting order (e.g., alphabetical, length-based, or numerical).

    @Override
    public List<T> sort(List<T> items, Comparator<T> comparator) {
        // If the list is empty or contains one element, it's already sorted
        if (items.size() < 2) {
            return items;
        }

        // Convert the list to an array for in-place sorting
        T[] array = (T[]) items.toArray((T[]) new Object[items.size()]);

        // Perform Bubble Sort
        bubbleSort(array, comparator);

        // Convert the sorted array back to a list and return
        return List.of(array);
    }

    private void bubbleSort(T[] array, Comparator<T> comparator) {
        int n = array.length;

        // Iterate through the array
        for (int i = 0; i < n - 1; i++) {
            // Traverse the array, "bubbling" the largest unsorted element to the end
            for (int j = 0; j < n - i - 1; j++) {
                // Swap elements if they are in the wrong order
                if (comparator.compare(array[j], array[j + 1]) > 0) {
                    swap(array, j, j + 1);
                }
            }
        }
    }

    private void swap(T[] array, int i, int j) {
        // Swap two elements in the array
        T temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

}
